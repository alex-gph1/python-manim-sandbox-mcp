#!/usr/bin/env python3
"""
Integration tests for the enhanced MCP sandbox server.
Tests all major functionality including:
- Package imports (absolute and relative)
- sys.path correctness
- Artifact generation
- Web app launch
- Error handling
"""

import sys
import json
import tempfile
import shutil
import unittest
from pathlib import Path
from unittest.mock import patch, MagicMock

# Add the project root to Python path for testing
sys.path.insert(0, str(Path(__file__).parent.parent))

# Import the server module  
from mcp_sandbox_server_stdio import (
    ExecutionContext, 
    execute, 
    get_execution_info,
    list_artifacts,
    cleanup_artifacts,
    start_repl,
    start_web_app,
    cleanup_temp_artifacts,
    monkey_patch_matplotlib,
    monkey_patch_pil,
    find_free_port,
    collect_artifacts
)

class TestSandboxIntegration(unittest.TestCase):\n    \"\"\"Integration tests for sandbox functionality.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test environment.\"\"\"\n        self.test_dir = Path(tempfile.mkdtemp())\n        self.original_ctx = None\n    \n    def tearDown(self):\n        \"\"\"Clean up test environment.\"\"\"\n        shutil.rmtree(self.test_dir, ignore_errors=True)\n        cleanup_artifacts()\n    \n    def test_package_imports_absolute(self):\n        \"\"\"Test absolute imports from sandbox package.\"\"\"\n        code = \"\"\"\nfrom sandbox.server.main import run_server, get_status\nfrom sandbox.utils.helpers import helper_function, process_data\n\nprint(\"Server:\", run_server())\nprint(\"Status:\", get_status())\nprint(\"Helper:\", helper_function())\nprint(\"Process:\", process_data(\"test\"))\n\"\"\"\n        \n        result = execute(code)\n        result_data = json.loads(result)\n        \n        self.assertIsNone(result_data['error'])\n        self.assertIn(\"Server: Server is running!\", result_data['stdout'])\n        self.assertIn(\"Status: Server status: OK\", result_data['stdout'])\n        self.assertIn(\"Helper: Helper function called!\", result_data['stdout'])\n        self.assertIn(\"Process: Processed: test\", result_data['stdout'])\n    \n    def test_package_imports_relative_within_module(self):\n        \"\"\"Test that relative imports are properly handled.\"\"\"\n        # This tests the import structure, not actual relative imports in exec\n        code = \"\"\"\n# Test that the package structure supports relative imports\nimport sys\nfrom pathlib import Path\n\n# Check that sandbox is importable\nimport sandbox\nprint(f\"Sandbox package: {sandbox}\")\n\n# Check that submodules are importable\nfrom sandbox import server, utils\nprint(f\"Server module: {server}\")\nprint(f\"Utils module: {utils}\")\n\"\"\"\n        \n        result = execute(code)\n        result_data = json.loads(result)\n        \n        self.assertIsNone(result_data['error'])\n        self.assertIn(\"Sandbox package:\", result_data['stdout'])\n        self.assertIn(\"Server module:\", result_data['stdout'])\n        self.assertIn(\"Utils module:\", result_data['stdout'])\n    \n    def test_sys_path_correctness(self):\n        \"\"\"Test that sys.path is correctly configured.\"\"\"\n        code = \"\"\"\nimport sys\nfrom pathlib import Path\n\nproject_root = \"/home/stan/Prod/sandbox\"\nvenv_path = Path(project_root) / \".venv\" / \"lib\" / \"python3.11\" / \"site-packages\"\n\nprint(f\"Project root in sys.path: {project_root in sys.path}\")\nprint(f\"First 3 sys.path entries: {sys.path[:3]}\")\nprint(f\"sys.executable: {sys.executable}\")\n\n# Test that we can import from the project\ntry:\n    import sandbox\n    print(\"✓ Can import sandbox package\")\nexcept ImportError as e:\n    print(f\"✗ Cannot import sandbox: {e}\")\n\"\"\"\n        \n        result = execute(code)\n        result_data = json.loads(result)\n        \n        self.assertIsNone(result_data['error'])\n        self.assertIn(\"Project root in sys.path: True\", result_data['stdout'])\n        self.assertIn(\"✓ Can import sandbox package\", result_data['stdout'])\n        \n        # Check execution info\n        info = json.loads(get_execution_info())\n        self.assertIn(\"/home/stan/Prod/sandbox\", info['sys_path_first_5'])\n    \n    def test_import_error_handling(self):\n        \"\"\"Test enhanced import error handling.\"\"\"\n        code = \"\"\"\nimport nonexistent_module\n\"\"\"\n        \n        result = execute(code)\n        result_data = json.loads(result)\n        \n        self.assertIsNotNone(result_data['error'])\n        self.assertEqual(result_data['error']['type'], 'ImportError')\n        self.assertEqual(result_data['error']['module'], 'nonexistent_module')\n        self.assertIn('traceback', result_data['error'])\n        self.assertIn('sys_path', result_data['error'])\n        self.assertIn('attempted_paths', result_data['error'])\n    \n    def test_artifact_generation_matplotlib(self):\n        \"\"\"Test matplotlib artifact generation.\"\"\"\n        code = \"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\n\nplt.figure(figsize=(8, 6))\nplt.plot(x, y)\nplt.title(\"Test Plot\")\nplt.show()\n\nprint(\"Plot generated\")\n\"\"\"\n        \n        result = execute(code)\n        result_data = json.loads(result)\n        \n        # Should not have errors (matplotlib might not be installed)\n        if result_data['error'] and 'matplotlib' in str(result_data['error']):\n            self.skipTest(\"Matplotlib not available\")\n        \n        if not result_data['error']:\n            self.assertIn(\"Plot generated\", result_data['stdout'])\n            # Check if artifacts were created\n            artifacts = result_data['artifacts']\n            if artifacts:\n                plot_artifacts = [a for a in artifacts if a['type'] == '.png']\n                self.assertGreater(len(plot_artifacts), 0)\n    \n    def test_general_error_handling(self):\n        \"\"\"Test general exception handling.\"\"\"\n        code = \"\"\"\nraise ValueError(\"Test error\")\n\"\"\"\n        \n        result = execute(code)\n        result_data = json.loads(result)\n        \n        self.assertIsNotNone(result_data['error'])\n        self.assertEqual(result_data['error']['type'], 'ValueError')\n        self.assertEqual(result_data['error']['message'], 'Test error')\n        self.assertIn('traceback', result_data['error'])\n    \n    def test_execution_context_persistence(self):\n        \"\"\"Test that execution context persists across calls.\"\"\"\n        # First execution: set a variable\n        code1 = \"test_var = 'persistent_value'\"\n        result1 = execute(code1)\n        result1_data = json.loads(result1)\n        self.assertIsNone(result1_data['error'])\n        \n        # Second execution: access the variable\n        code2 = \"print(f'Retrieved: {test_var}')\"\n        result2 = execute(code2)\n        result2_data = json.loads(result2)\n        \n        self.assertIsNone(result2_data['error'])\n        self.assertIn(\"Retrieved: persistent_value\", result2_data['stdout'])\n    \n    def test_interactive_mode_flag(self):\n        \"\"\"Test interactive mode flag.\"\"\"\n        code = \"print('Hello, interactive world!')\"\n        result = execute(code, interactive=True)\n        result_data = json.loads(result)\n        \n        self.assertIsNone(result_data['error'])\n        self.assertIn(\"Hello, interactive world!\", result_data['stdout'])\n        self.assertIn(\"Interactive mode enabled\", result_data['stdout'])\n    \n    def test_artifact_collection_and_cleanup(self):\n        \"\"\"Test artifact collection and cleanup functionality.\"\"\"\n        # Generate some fake artifacts\n        code = \"\"\"\nimport tempfile\nfrom pathlib import Path\n\n# This won't actually create artifacts in the artifacts dir,\n# but we can test the infrastructure\nprint(\"Testing artifact infrastructure\")\n\"\"\"\n        \n        result = execute(code)\n        result_data = json.loads(result)\n        \n        self.assertIsNone(result_data['error'])\n        \n        # Test listing artifacts\n        artifacts_list = list_artifacts()\n        self.assertIsInstance(artifacts_list, str)\n        \n        # Test cleanup\n        cleanup_result = cleanup_artifacts()\n        self.assertIn(\"cleaned up\", cleanup_result.lower())\n    \n    def test_execution_info(self):\n        \"\"\"Test execution environment information.\"\"\"\n        info = get_execution_info()\n        info_data = json.loads(info)\n        \n        required_keys = [\n            'project_root', 'venv_path', 'venv_active', \n            'sys_executable', 'sys_path_length', 'sys_path_first_5'\n        ]\n        \n        for key in required_keys:\n            self.assertIn(key, info_data)\n        \n        self.assertEqual(info_data['project_root'], '/home/stan/Prod/sandbox')\n        self.assertIsInstance(info_data['sys_path_length'], int)\n        self.assertIsInstance(info_data['sys_path_first_5'], list)\n    \n    def test_find_free_port(self):\n        \"\"\"Test free port finding functionality.\"\"\"\n        port = find_free_port(8000)\n        self.assertIsInstance(port, int)\n        self.assertGreaterEqual(port, 8000)\n        self.assertLess(port, 8100)\n    \n    def test_json_output_format(self):\n        \"\"\"Test that execute returns valid JSON.\"\"\"\n        code = \"print('JSON test')\"\n        result = execute(code)\n        \n        # Should be valid JSON\n        try:\n            result_data = json.loads(result)\n        except json.JSONDecodeError:\n            self.fail(\"execute() did not return valid JSON\")\n        \n        # Check required keys\n        required_keys = ['stdout', 'stderr', 'error', 'artifacts', 'execution_info']\n        for key in required_keys:\n            self.assertIn(key, result_data)\n\nclass TestMonkeyPatching(unittest.TestCase):\n    \"\"\"Test monkey patching functionality.\"\"\"\n    \n    def test_matplotlib_monkey_patch(self):\n        \"\"\"Test matplotlib monkey patching.\"\"\"\n        # This will return False if matplotlib is not installed\n        result = monkey_patch_matplotlib()\n        self.assertIsInstance(result, bool)\n    \n    def test_pil_monkey_patch(self):\n        \"\"\"Test PIL monkey patching.\"\"\"\n        # This will return False if PIL is not installed\n        result = monkey_patch_pil()\n        self.assertIsInstance(result, bool)\n\nif __name__ == '__main__':\n    # Create tests directory if it doesn't exist\n    test_dir = Path(__file__).parent\n    test_dir.mkdir(exist_ok=True)\n    \n    # Run tests\n    unittest.main(verbosity=2)
